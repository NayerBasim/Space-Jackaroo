package engine.board;

import java.util.ArrayList;

import engine.GameManager;
import exception.CannotFieldException;
import exception.IllegalDestroyException;
import exception.IllegalMovementException;
import exception.IllegalSwapException;
import exception.InvalidMarbleException;
import model.Colour;
import model.player.Marble;

@SuppressWarnings("unused")
public class Board implements BoardManager {
    private final ArrayList<Cell> track;
    private final ArrayList<SafeZone> safeZones;
	private final GameManager gameManager;
    private int splitDistance;

    public Board(ArrayList<Colour> colourOrder, GameManager gameManager) {
        this.track = new ArrayList<>();
        this.safeZones = new ArrayList<>();
        this.gameManager = gameManager;
        
        for (int i = 0; i < 100; i++) {
            this.track.add(new Cell(CellType.NORMAL));
            
            if (i % 25 == 0) 
                this.track.get(i).setCellType(CellType.BASE);
            
            else if ((i+2) % 25 == 0) 
                this.track.get(i).setCellType(CellType.ENTRY);
        }

        for(int i = 0; i < 8; i++)
            this.assignTrapCell();

        for (int i = 0; i < 4; i++)
            this.safeZones.add(new SafeZone(colourOrder.get(i)));

        splitDistance = 3;
    }

    public ArrayList<Cell> getTrack() {
        return this.track;
    }

    public ArrayList<SafeZone> getSafeZones() {
        return this.safeZones;
    }
    
    @Override
    public int getSplitDistance() {
        return this.splitDistance;
    }

    public void setSplitDistance(int splitDistance) {
        this.splitDistance = splitDistance;
    }
   
    private void assignTrapCell() {
        int randIndex = -1;
        
        do
            randIndex = (int)(Math.random() * 100); 
        while(this.track.get(randIndex).getCellType() != CellType.NORMAL || this.track.get(randIndex).isTrap());
        
        this.track.get(randIndex).setTrap(true);
    }
    
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    
    private ArrayList<Cell> getSafeZone(Colour colour){
    	for(int i = 0 ; i < safeZones.size() ; i++){
    		if(safeZones.get(i).getColour().equals(colour)){
    			return safeZones.get(i).getCells();
    		}
    	}
    	return null;
    }
    
    
    private int getPositionInPath(ArrayList<Cell> path, Marble marble){
    	for(int i = 0 ; i < path.size(); i++){
    		if(path.get(i).getMarble() != null && path.get(i).getMarble().equals(marble)){
    			return i;
    		}
    	}
    	return -1;
    }
    
    
    private int getBasePosition(Colour colour){
    	for(int i = 0 ; i < safeZones.size(); i++){
    		if(safeZones.get(i).getColour().equals(colour)){
    			return i*25;
    		}
    	}
    	return -1;
    }
    
    
    private int getEntryPosition(Colour colour){
    	int base = getBasePosition(colour);
    	if(base == -1)
    		return -1;
    	else if(base == 0)
    		return 98;
    	else{
    		return base - 2;
    	}
    }
    
    private ArrayList<Cell> validateSteps(Marble marble, int steps) throws IllegalMovementException{
    	
    	ArrayList<Cell> safe_zone = getSafeZone(marble.getColour());
    	int pos_track = getPositionInPath(track, marble);
    	int pos_safe = getPositionInPath(safe_zone, marble);
    	ArrayList<Cell> path  = new ArrayList<Cell>();
    	Colour player_colour  = gameManager.getActivePlayerColour();
    	
    	if(pos_track == -1 && pos_safe == -1)
    		throw new IllegalMovementException("marble is not on track or in its safe zone");
    	
    	if(pos_track != -1){
    		int dist_to_entry = getEntryPosition(marble.getColour()) - pos_track;
    		if(dist_to_entry < 0)
    			dist_to_entry += 100;
    		
    		
    		if(steps > dist_to_entry + 4)
    			throw new IllegalMovementException("rank of played card it too high");
    		else if(steps > dist_to_entry && player_colour.equals(marble.getColour())){
    			
    			for(int i = 0 ; i <= dist_to_entry; i++){
					path.add(track.get((pos_track + i) % 100));
				}
    			for(int i = 0 ; i < steps - dist_to_entry; i++){
					path.add(safe_zone.get((pos_safe + i) % 100));
				}
    		}else{
    			if(steps > 0)
    				for(int i = 0 ; i <= steps; i++){
    					path.add(track.get((pos_track + i) % 100));
    				}
    			else
    				for(int i = 0 ; i >= steps; i--){
    					int pos = pos_track + i >= 0 ? pos_track + i : pos_track + i + 100;
    					path.add(track.get(pos_track + i));
    				}
    		}
    	}else{
    		if(steps < 0)
    			throw new IllegalMovementException("cannot move backwards into safezone");
    		else if(steps > 3 - pos_safe)
    			throw new IllegalMovementException("rank of played card is too high");
    		else{
    			for(int i = 0 ; i <= steps; i++){
					path.add(safe_zone.get(pos_safe + i));
				}
    		}
    	}
    	
    	return path;
    	
    }
    private void validatePath(Marble marble, ArrayList<Cell> fullPath, boolean destroy) throws IllegalMovementException{
//    	� Self-Blocking: A marble cannot move if there is another marble owned by the same
//    	player either in its path or at the target position. Meaning, I, as a player cannot
//    	bypass or destroy my own marble.
//    	� Path Blockage: Movement is invalid if there is more than one marble (owned by
//    	any player) blocking the path.
//    	� Safe Zone Entry: A marble cannot enter its player�s Safe Zone if any marble is
//    	stationed at its player�s Safe Zone Entry.
//    	� Base Cell Blockage: A marble�s movement is blocked if another player�s marble is
//    	in its player�s Base cell, either in the path or target position.
//    	� Rule Breakage: Special cards can break some of the movement rules (detailed
//    	individually for each card later)
    	
    	Colour player_colour  = gameManager.getActivePlayerColour();
    	int num_marbles = 0;
    	Cell target = fullPath.get(fullPath.size() - 1);
    	
    	for(int i = 1 ; i < fullPath.size() - 1; i++){
    		if(fullPath.get(i).getMarble() != null){
    			num_marbles += 1;
    			Marble m = fullPath.get(i).getMarble();
    			
    			if(!destroy){
    			if(m.getColour().equals(player_colour))
    				throw new IllegalMovementException("cannot pass your own marble");
    			if(num_marbles >= 2)
    				throw new IllegalMovementException("cannot pass more than one marble on path");
    			if(fullPath.get(i).getCellType().equals(CellType.ENTRY) && fullPath.get(i+1).getCellType().equals(CellType.SAFE))
    				throw new IllegalMovementException("cannot enter safe zone if a marble is on safe zone entry");
    			}
    			if(fullPath.get(i) == track.get(getBasePosition(m.getColour())))
    				throw new IllegalMovementException("cannot pass a marble in its base cell");
    			if(fullPath.get(i).getCellType().equals(CellType.ENTRY))
    				throw new IllegalMovementException("cannot destroy a marble in safe zone");
    			
    		}			
    			
    	}
    	if(target.getMarble() != null ){
	    	if(!destroy){
		    	if( target.getMarble().getColour().equals(player_colour))
					throw new IllegalMovementException("cannot destroy your own marble");
	    	}
	    	if( target == track.get(getBasePosition(target.getMarble().getColour())))
				throw new IllegalMovementException("cannot destroy a marble in its base cell");
	    	
	    	if(target.getCellType().equals(CellType.ENTRY))
				throw new IllegalMovementException("cannot destroy a marble in safe zone");
    	}
    }
    
    private void move(Marble marble, ArrayList<Cell> fullPath, boolean destroy) throws IllegalDestroyException{
    	fullPath.get(0).setMarble(null);
    	
    	if(destroy)
	    	for(int i = 0 ; i < fullPath.size() - 1 ; i++){
	    		if(fullPath.get(i).getMarble() != null)
	    			destroyMarble(fullPath.get(i).getMarble());
	    	}
	    
    	Cell target = fullPath.get(fullPath.size() - 1);
    	if(target.getMarble() != null)
    		destroyMarble(target.getMarble());
    	
    	target.setMarble(marble);
    	
    	if(target.isTrap()){
    		destroyMarble(marble);
    		target.setTrap(false);
    		assignTrapCell();
    	}
    	
    }
    
    
    private void validateSwap(Marble marble_1, Marble marble_2) throws IllegalSwapException{
    	
    	if(getPositionInPath(track,marble_1) == -1 || getPositionInPath(track,marble_2) == -1)
    		throw new IllegalSwapException("Cant swap marbles not on track");
    	if(getPositionInPath(track,marble_2) == getBasePosition(marble_2.getColour()))
    		throw new IllegalSwapException("Cant swap a marble on its base cell");
    }
    
    
    private void validateDestroy(int positionInPath) throws IllegalDestroyException{
    	if(positionInPath == -1)
    		throw new IllegalDestroyException("Cannot destroy a marble not on track");
    	Marble m = track.get(positionInPath).getMarble();
    	if( getBasePosition(m.getColour()) == positionInPath)
    		throw new IllegalDestroyException("Cannot destroy a marble on its base cell");
    }
    
    
    private void validateFielding(Cell occupiedBaseCell) throws CannotFieldException{
    	Colour c = occupiedBaseCell.getMarble().getColour();
    	if(track.get(getBasePosition(c)) == occupiedBaseCell)
    		throw new CannotFieldException("marble of the same colour as the player is already in the Base Cell");
    		
    		
    }
    
    
    private void validateSaving(int positionInSafeZone, int positionOnTrack) throws InvalidMarbleException{
    	if(positionInSafeZone != -1 || positionOnTrack == -1)
    		throw new InvalidMarbleException("Cannot save a marble not on track or in safe zone");
 
    }
    
    
    public void moveBy(Marble marble, int steps, boolean destroy) throws IllegalMovementException, IllegalDestroyException{
    	ArrayList<Cell> path = validateSteps(marble, steps);
    	validatePath(marble,path,destroy);
    	move(marble,path,destroy);
    	
    }
    
    public void swap(Marble marble_1, Marble marble_2) throws IllegalSwapException{
    	validateSwap(marble_1,marble_2);
    	int pos1 = getPositionInPath(track, marble_1);
    	int pos2 = getPositionInPath(track, marble_2);
    			
    	track.get(pos1).setMarble(marble_2);
    	track.get(pos2).setMarble(marble_1);
    }
    
    
    public void destroyMarble(Marble marble) throws IllegalDestroyException{
    	
    	if(gameManager.getActivePlayerColour() != marble.getColour()){
    		validateDestroy(getPositionInPath(track,marble));
    	}
    	track.get(getPositionInPath(track,marble)).setMarble(null);
    	 gameManager.sendHome(marble);
    	
    }
    
    
    public void sendToBase(Marble marble) throws CannotFieldException, IllegalDestroyException{
    	Cell c = track.get(getBasePosition(marble.getColour()));
    	if(c.getMarble() != null)
    		validateFielding(c);
    	c.setMarble(marble);
    	
    }
    
    
    public void sendToSafe(Marble marble) throws InvalidMarbleException{
    	
    	ArrayList<Cell> safe = getSafeZone(marble.getColour());
    	validateSaving(getPositionInPath(safe, marble), getPositionInPath(track, marble));
    	
    	track.get(getPositionInPath(track,marble)).setMarble(null);
    	
    	ArrayList<Cell> emptySafe = new ArrayList<Cell>();
    	
    	for(int i = 0 ; i < safe.size(); i++){
    		if(safe.get(i).getMarble() == null)
    			emptySafe.add(safe.get(i));
    	}
    	int randomIndex = (int)(Math.random() * emptySafe.size());
    	emptySafe.get(randomIndex).setMarble(marble);
    	
    }
    
    public ArrayList<Marble> getActionableMarbles(){
    	
    	ArrayList<Marble> marbles = new ArrayList<Marble>();
    	ArrayList<Cell> safe = getSafeZone(gameManager.getActivePlayerColour());
    	
    	for(int i = 0 ; i < track.size(); i++){
    		if(track.get(i).getMarble() != null){
    			marbles.add(track.get(i).getMarble());
    		}
    	}
    	for(int i = 0 ; i < safe.size(); i++){
    		if(safe.get(i).getMarble() != null){
    			marbles.add(safe.get(i).getMarble());
    		}
    	}
    	return marbles;  	
    }
    
    
}
