//package engine;
//
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.Arrays;
//import java.util.Collections;
//import java.util.Random;
//import engine.board.Board;
//import engine.board.SafeZone;
//import exception.CannotDiscardException;
//import exception.CannotFieldException;
//import exception.GameException;
//import exception.IllegalDestroyException;
//import exception.InvalidCardException; 
//import exception.InvalidMarbleException;
//import exception.SplitOutOfRangeException;
//import model.Colour;
//import model.card.Card;
//import model.card.Deck;
//import model.player.*;
//
//@SuppressWarnings("unused")
//public class Game implements GameManager {
//    public final Board board; //made this public
//    private final ArrayList<Player> players;
//	private int currentPlayerIndex;
//    private final ArrayList<Card> firePit;
//    private int turn;
//
//    public Game() throws IOException {
//        turn = 0;
//        currentPlayerIndex = 0;
//        firePit = new ArrayList<>();
//
//        ArrayList<Colour> colourOrder = new ArrayList<>();
//        
//        colourOrder.addAll(Arrays.asList(Colour.values()));
//        
//        Collections.shuffle(colourOrder);
//        
//        this.board = new Board(colourOrder, this);
//        
//        Deck.loadCardPool(this.board, (GameManager)this);
//        
//        this.players = new ArrayList<>();
////        this.players.add(new Player(playerName, colourOrder.get(0)));
//        
//        for (int i = 0; i < 4; i++) 
//            this.players.add(new CPU("CPU " + i, colourOrder.get(i), this.board));
//        
//        for (int i = 0; i < 4; i++) 
//            this.players.get(i).setHand(Deck.drawCards());
//        
//    }
//    public int getcurrentPlayerIndex(){
//    	return this.currentPlayerIndex;
//    }
//    
//    public Board getBoard() {
//        return board;
//    }
//
//    public ArrayList<Player> getPlayers() {
//        return players;
//    }
//
//    public ArrayList<Card> getFirePit() {
//        return firePit;
//    }
//    //--------------------------------
//    
//    public void selectCard(Card card) throws InvalidCardException{
//    	players.get(currentPlayerIndex).selectCard(card);
//    }
//    
//    public void selectMarble(Marble marble) throws InvalidMarbleException{
//    	players.get(currentPlayerIndex).selectMarble(marble);
//    }
//    public void deselectAll(){
//    	players.get(currentPlayerIndex).deselectAll();
//    }
//    public void editSplitDistance(int splitDistance) throws SplitOutOfRangeException{
//    	if(splitDistance>=1 && splitDistance<=6){
//    		board.setSplitDistance(splitDistance);
//    	}
//    	else{
//    		throw new SplitOutOfRangeException();
//    	}
//    }
//    public  boolean canPlayTurn(){
//    	
//    	int handSize = players.get(currentPlayerIndex).getHand().size();
//    	if (handSize + turn ==4){
//    		return true;
//    	}
//    	else{
//    		return false;
//    	}
//    }
//    public void playPlayerTurn() throws GameException{
//	    players.get(currentPlayerIndex).play();	
//	    
//    }
//    
//    public void endPlayerTurn(){
//    	Card selectedCard = players.get(currentPlayerIndex).getSelectedCard();
//    	firePit.add(selectedCard);
//    	players.get(currentPlayerIndex).deselectAll();
//    	players.get(currentPlayerIndex).getHand().remove(selectedCard);
//    	currentPlayerIndex++;
//    	if(currentPlayerIndex >=4){
//    		turn++;
//    		currentPlayerIndex=0;
//    	}
//    	if(turn>=4){
//    		turn=0;
//    		for(int i =0 ;i<4;i++){
//    			if(Deck.getPoolSize()<4){
//    				Deck.refillPool(firePit);
//    				firePit.clear();
//    			}
//    			players.get(i).setHand(Deck.drawCards());
//    		}	
//    	}	
//    }  
//    public Colour checkWin(){
//    	boolean win = false;
//    	ArrayList<SafeZone> safeZones = board.getSafeZones();
//    	for(int i=0;i<4;i++){
//    		win = safeZones.get(i).isFull();
//    		if(win){
//    			return safeZones.get(i).getColour();
//    		}
//    	}
//    	return null;	
//    }
//    public void sendHome(Marble marble){
//    	Colour marbelColour = marble.getColour();
//    	for(int i = 0 ; i<4 ; i++){
//    		if(players.get(i).getColour() == marbelColour){
//    			players.get(i).regainMarble(marble);
//    		}
//    	}
//    }
//    public void fieldMarble() throws CannotFieldException, IllegalDestroyException{
//    	Marble marble = players.get(currentPlayerIndex).getOneMarble();
//    	if(marble == null){
//    		throw new CannotFieldException();
//    	}
//    	
//    	else{
//    		board.sendToBase(marble);
//    		players.get(currentPlayerIndex).getMarbles().remove(marble);
//    	}
//    }
//    public void discardCard(Colour colour) throws CannotDiscardException{
//    	for(int i =0;i<4;i++){
//    		if(colour == players.get(i).getColour()){
//    			players.get(i).removeRandomCard();
//    		}
//    	}
//    }
//    public void discardCard() throws CannotDiscardException{
//    	Random rand = new Random();
//    	int index ;
//    	do
//    		index = rand.nextInt(4);
//    	while(index == currentPlayerIndex);
//    	players.get(index).removeRandomCard();
//    }
//    public Colour getActivePlayerColour(){
//    	return players.get(currentPlayerIndex).getColour();
//    }
//    public Colour getNextPlayerColour(){
//
//    	if(currentPlayerIndex<3)
//    		return players.get(currentPlayerIndex+1).getColour();
//    	return players.get(0).getColour();
//    }
//    
//    
////    public static void main(String[] args) throws IOException, GameException   {
////
////
////        Game game1 = new Game();
////        Colour win_color = null;
////
////        
////        while(win_color == null){
////        	if(game1.canPlayTurn()){
////        		game1.playPlayerTurn();
////        		game1.endPlayerTurn();
////        	}
////        	win_color = game1.checkWin();
////        	ArrayList<SafeZone> safeZones = game1.board.getSafeZones();
////        	for(int i = 0 ; i < 4; i++)
////        		System.out.println(safeZones.get(1).getCells().get(i).getMarble());
////
////
////        	
////            
////        }
////        System.out.println(win_color);
////
////        }
////    public static void main(String[] args) throws IOException, GameException   {
////
////
////        Game game1 = new Game();
////        Colour win_color = null;
////        int i =0;
////        while(win_color == null){
////            game1.players.get(i).play();
////        	ArrayList<SafeZone> safeZones = game1.board.getSafeZones();
////        	for(int v = 0 ; v < 4; v++)
////        		System.out.println(safeZones.get(1).getCells().get(v).getMarble());
////            win_color = game1.checkWin();
////            i++;
////            if(i==4)
////                i=0;
////        }
////        System.out.println(win_color);
////
////        }
//    
//    // This makes no sense
//    // I am sorry for whoever has to debug this 
//    // RIP :( 
//    // We have spent a total of 50000 man hours on this code
//    // the road seems empty and deserted
//    // no finish line in sight
//    // I surrender my control to the code monster 
//    // Goodbye world....
//    // System.out.println("Goodbye World");
//    
//    
//    
//    
//}

package engine;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

import engine.board.Board;
import engine.board.SafeZone;
import exception.CannotDiscardException;
import exception.CannotFieldException;
import exception.GameException;
import exception.IllegalDestroyException;
import exception.InvalidCardException;
import exception.InvalidMarbleException;
import exception.SplitOutOfRangeException;
import model.Colour;
import model.card.Card;
import model.card.Deck;
import model.player.*;

@SuppressWarnings("unused")
public class Game implements GameManager {
    private final Board board;
    private final ArrayList<Player> players;
	private int currentPlayerIndex;
    private final ArrayList<Card> firePit;
    private int turn;

    public Game(String playerName) throws IOException {
        turn = 0;
        currentPlayerIndex = 0;
        firePit = new ArrayList<>();

        ArrayList<Colour> colourOrder = new ArrayList<>();
        
        colourOrder.addAll(Arrays.asList(Colour.values()));
        
        Collections.shuffle(colourOrder);
        
        this.board = new Board(colourOrder, this);
        
        Deck.loadCardPool(this.board, (GameManager)this);
        
        this.players = new ArrayList<>();
        this.players.add(new Player(playerName, colourOrder.get(0)));
        
        for (int i = 1; i < 4; i++) 
            this.players.add(new CPU("CPU " + i, colourOrder.get(i), this.board));
        
        for (int i = 0; i < 4; i++) 
            this.players.get(i).setHand(Deck.drawCards());
        
    }
    
    public Board getBoard() {
        return board;
    }

    public ArrayList<Player> getPlayers() {
        return players;
    }

    public ArrayList<Card> getFirePit() {
        return firePit;
    }
    
    public void selectCard(Card card) throws InvalidCardException {
        players.get(currentPlayerIndex).selectCard(card);
    }

    public void selectMarble(Marble marble) throws InvalidMarbleException {
        players.get(currentPlayerIndex).selectMarble(marble);
    }

    public void deselectAll() {
        players.get(currentPlayerIndex).deselectAll();
    }

    public void editSplitDistance(int splitDistance) throws SplitOutOfRangeException {
        if(splitDistance < 1 || splitDistance > 6)
            throw new SplitOutOfRangeException();

        board.setSplitDistance(splitDistance);
    }

    public boolean canPlayTurn() {
        return players.get(currentPlayerIndex).getHand().size() == (4 - turn);
    }

    public void playPlayerTurn() throws GameException {
        players.get(currentPlayerIndex).play();
    }

    public void endPlayerTurn() {
        Card selected = players.get(currentPlayerIndex).getSelectedCard();
        players.get(currentPlayerIndex).getHand().remove(selected);
        firePit.add(selected);
        players.get(currentPlayerIndex).deselectAll();
        
        currentPlayerIndex = (currentPlayerIndex + 1) % 4;
        
        if(currentPlayerIndex == 0 && turn < 3) 
            turn++;
        
        else if (currentPlayerIndex == 0 && turn == 3) {
        	turn = 0;
        	for (Player p : players) {
              if(Deck.getPoolSize() < 4) {
	              Deck.refillPool(firePit);
	              firePit.clear();
              }
              ArrayList<Card> newHand = Deck.drawCards();
              p.setHand(newHand);
        	}
        		
        }
        
    }

    public Colour checkWin() {
        for(SafeZone safeZone : board.getSafeZones()) 
            if(safeZone.isFull())
                return safeZone.getColour();
    
        return null;
    }

    @Override
    public void sendHome(Marble marble) {
        for (Player player : players) {
            if (player.getColour() == marble.getColour()) {
                player.regainMarble(marble);
                break;
            }
        }
    }

    @Override
    public void fieldMarble() throws CannotFieldException, IllegalDestroyException {
        Marble marble = players.get(currentPlayerIndex).getOneMarble();
        
        if (marble == null)
        	throw new CannotFieldException("No marbles left in the Home Zone to field.");
        
        board.sendToBase(marble);
        players.get(currentPlayerIndex).getMarbles().remove(marble);
    }
    
    @Override
    public void discardCard(Colour colour) throws CannotDiscardException {
        for (Player player : players) {
            if (player.getColour() == colour) {
                int handSize = player.getHand().size();
                if(handSize == 0)
                    throw new CannotDiscardException("Player has no cards to discard.");
                int randIndex = (int) (Math.random() * handSize);
                this.firePit.add(player.getHand().remove(randIndex));
            }
        }
    }

    @Override
    public void discardCard() throws CannotDiscardException {
        int randIndex = (int) (Math.random() * 4);
        while(randIndex == currentPlayerIndex)
            randIndex = (int) (Math.random() * 4);

        discardCard(players.get(randIndex).getColour());
    }

    @Override
    public Colour getActivePlayerColour() {
        return players.get(currentPlayerIndex).getColour();
    }

    @Override
    public Colour getNextPlayerColour() {
        return players.get((currentPlayerIndex + 1) % 4).getColour();
    }
    
}
